
/*CASE1 Soru 1
Soru 1
Aylık olarak order dağılımını inceleyiniz. Tarih verisi için order_approved_at kullanılmalıdır.*/

SELECT (DATE_TRUNC('month',O.ORDER_APPROVED_AT))::date AS PAYMENT_MONTH,
	COUNT(O.ORDER_ID) AS ORDER_COUNT
FROM PAYMENTS AS P
JOIN ORDERS AS O ON O.ORDER_ID = P.ORDER_ID
WHERE O.ORDER_APPROVED_AT IS NOT NULL
GROUP BY 1
ORDER BY PAYMENT_MONTH



/* CASE1 
Soru 2 
-Aylık olarak order status kırılımında order sayılarını inceleyiniz. Sorgu sonucunda çıkan outputu excel ile görselleştiriniz. 
Dramatik bir düşüşün ya da yükselişin olduğu aylar var mı? Veriyi inceleyerek yorumlayınız.*/

SELECT DATE_TRUNC('month',O.ORDER_APPROVED_AT) AS PAYMENT_MONTH,
	O.ORDER_STATUS,
	COUNT(P.ORDER_ID) AS ORDER_COUNT
FROM PAYMENTS AS P
LEFT JOIN ORDERS AS O ON O.ORDER_ID = P.ORDER_ID AND O.ORDER_STATUS = 'shipped' --canceled,invoiced,processing,approved
WHERE O.ORDER_APPROVED_AT IS NOT NULL
GROUP BY 1,2
ORDER BY PAYMENT_MONTH,2


 /* CASE1 
Soru 3
 Ürün kategorisi kırılımında sipariş sayılarını inceleyiniz. 
 Özel günlerde öne çıkan kategoriler nelerdir? Örneğin yılbaşı, sevgililer günü… */ 

-- teslimat süresi ortalaması

select 
avg(o.order_delivered_customer_date-o.order_purchase_timestamp) as avg_delivery_time
from orders o


-- ürün kategorisi kırılımı
SELECT DISTINCT P.PRODUCT_CATEGORY_NAME,
	T.CATEGORY_NAME_ENGLISH,
	COUNT(DISTINCT O.ORDER_ID) AS ORDER_COUNT
FROM ORDERS O
LEFT JOIN ORDER_ITEMS OI ON O.ORDER_ID = OI.ORDER_ID
LEFT JOIN PRODUCTS P ON OI.PRODUCT_ID = P.PRODUCT_ID
LEFT JOIN TRANSLATION T ON T.CATEGORY_NAME = P.PRODUCT_CATEGORY_NAME
LEFT JOIN PAYMENTS PY ON O.ORDER_ID = PY.ORDER_ID
WHERE P.PRODUCT_CATEGORY_NAME IS NOT NULL
GROUP BY 1,2
ORDER BY ORDER_COUNT DESC






-- özel günler
-- 24 KASIM 2017 BLACK FRIDAY
SELECT 
	DISTINCT P.PRODUCT_CATEGORY_NAME,
	T.CATEGORY_NAME_ENGLISH,
	COUNT(DISTINCT O.ORDER_ID) AS ORDER_COUNT
FROM ORDERS O
LEFT JOIN ORDER_ITEMS OI ON O.ORDER_ID = OI.ORDER_ID
LEFT JOIN PRODUCTS P ON OI.PRODUCT_ID = P.PRODUCT_ID
LEFT JOIN TRANSLATION T ON T.CATEGORY_NAME = P.PRODUCT_CATEGORY_NAME
LEFT JOIN PAYMENTS PY ON O.ORDER_ID = PY.ORDER_ID
WHERE O.ORDER_PURCHASE_TIMESTAMP::date  = '2017-11-24'
GROUP BY 1,2
ORDER BY ORDER_COUNT DESC
 
 -- 14 ŞUBAT SEVGİLİLER GÜNÜ (HEM 2017 HEM 2018 incelenecek)
SELECT DISTINCT P.PRODUCT_CATEGORY_NAME,
	   T.CATEGORY_NAME_ENGLISH,
	   COUNT(DISTINCT O.ORDER_ID) AS ORDER_COUNT
FROM ORDERS O
LEFT JOIN ORDER_ITEMS OI ON O.ORDER_ID = OI.ORDER_ID
LEFT JOIN PRODUCTS P ON OI.PRODUCT_ID = P.PRODUCT_ID
LEFT JOIN TRANSLATION T ON T.CATEGORY_NAME = P.PRODUCT_CATEGORY_NAME
LEFT JOIN PAYMENTS PY ON O.ORDER_ID = PY.ORDER_ID
WHERE O.ORDER_DELIVERED_CUSTOMER_DATE BETWEEN '2017-02-07' AND '2017-02-14'
GROUP BY 1,2
ORDER BY ORDER_COUNT DESC
 
 -- 2018 01 OCAK YILBAŞI
SELECT DISTINCT P.PRODUCT_CATEGORY_NAME,
	   T.CATEGORY_NAME_ENGLISH,
	   COUNT(DISTINCT O.ORDER_ID) AS ORDER_COUNT
FROM ORDERS O
LEFT JOIN ORDER_ITEMS OI ON O.ORDER_ID = OI.ORDER_ID
LEFT JOIN PRODUCTS P ON OI.PRODUCT_ID = P.PRODUCT_ID
LEFT JOIN TRANSLATION T ON T.CATEGORY_NAME = P.PRODUCT_CATEGORY_NAME
LEFT JOIN PAYMENTS PY ON O.ORDER_ID = PY.ORDER_ID
WHERE O.ORDER_DELIVERED_CUSTOMER_DATE BETWEEN '2017-12-25' AND '2018-01-01'
GROUP BY 1,2
ORDER BY ORDER_COUNT DESC
 /*CASE1 
Soru 3
Haftanın günleri(pazartesi, perşembe, ….) ve ay günleri (ayın 1’i,2’si gibi) bazında order sayılarını inceleyiniz.
Yazdığınız sorgunun outputu ile excel’de bir görsel oluşturup yorumlayınız. */ 
--haftanın günlerine göre
SELECT DISTINCT (TO_CHAR(ORDER_PURCHASE_TIMESTAMP,'DAY')) AS DAYOFWEEK,
	   COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT
FROM ORDERS
GROUP BY DAYOFWEEK
ORDER BY ORDER_COUNT DESC

-- ayın günlerine göre
SELECT EXTRACT(DAY FROM ORDER_PURCHASE_TIMESTAMP) AS DAY_OF_MONTH,
	COUNT(DISTINCT ORDER_ID) AS ORDER_COUNT
FROM ORDERS
GROUP BY DAY_OF_MONTH
ORDER BY DAY_OF_MONTH

 /*
Case 2 : Müşteri Analizi 
Soru 1 : 
-Hangi şehirlerdeki müşteriler daha çok alışveriş yapıyor?
Müşterinin şehrini en çok sipariş verdiği şehir olarak belirleyip analizi ona göre yapınız. 

-- sonuç şehir nüfusları ile doğru orantılı.

Örneğin; Sibel Çanakkale’den 3, Muğla’dan 8 ve İstanbul’dan 10 sipariş olmak üzere 3 farklı şehirden sipariş veriyor. 
Sibel’in şehrini en çok sipariş verdiği şehir olan İstanbul olarak seçmelisiniz ve 
Sibel’in yaptığı siparişleri İstanbul’dan 21 sipariş vermiş şekilde görünmelidir. */

WITH CUSTOMERMAXORDERS AS(
	SELECT C.CUSTOMER_UNIQUE_ID,
		C.CUSTOMER_CITY,
		COUNT(O.ORDER_ID) AS ORDER_COUNT,
		RANK() OVER (PARTITION BY C.CUSTOMER_UNIQUE_ID ORDER BY COUNT(O.ORDER_ID) DESC,O.ORDER_PURCHASE_TIMESTAMP DESC) AS RNK
		FROM CUSTOMERS C
		JOIN ORDERS O ON C.CUSTOMER_ID = O.CUSTOMER_ID
		GROUP BY C.CUSTOMER_UNIQUE_ID,C.CUSTOMER_CITY,O.ORDER_ID
)
SELECT CUSTOMER_CITY AS MOST_ORDERS_CITY,
	COUNT(ORDER_COUNT) AS ORDER_COUNT
FROM CUSTOMERMAXORDERS
WHERE RNK = 1
GROUP BY 1
ORDER BY ORDER_COUNT DESC


/*
Case 3: Satıcı Analizi
Soru 1 : 
-Siparişleri en hızlı şekilde müşterilere ulaştıran satıcılar kimlerdir? Top 5 getiriniz.
Bu satıcıların order sayıları ile ürünlerindeki yorumlar ve puanlamaları inceleyiniz ve yorumlayınız.
*/

/* Bu sorguda en hızlı getiren satıcıların hepsi sadece 1 kez satış yapmış  */
SELECT S.SELLER_ID,
	AVG(O.ORDER_DELIVERED_CUSTOMER_DATE - O.ORDER_PURCHASE_TIMESTAMP) AS AVG_DELIVERY_TIME,
	COUNT(O.ORDER_ID) AS ORDER_COUNT,
	ROUND(AVG(R.REVIEW_SCORE),2) AS AVG_REVIEW_SCORE,
	COUNT(R.REVIEW_COMMENT_MESSAGE) AS COMMENT_COUNT
FROM SELLERS S
JOIN ORDER_ITEMS OI ON S.SELLER_ID = OI.SELLER_ID
JOIN ORDERS O ON O.ORDER_ID = OI.ORDER_ID
LEFT JOIN REVIEWS R ON O.ORDER_ID = R.ORDER_ID 
WHERE O.ORDER_DELIVERED_CUSTOMER_DATE IS NOT NULL
GROUP BY S.SELLER_ID
ORDER BY AVG_DELIVERY_TIME
LIMIT 5


/* Bu sorguda ortalama order sayısından fazla satış yapmış ve en hızlı teslimat yapan ilk 5 satıcı 
getirilmiştir.*/ 




SELECT S.SELLER_ID,
	AVG(O.ORDER_DELIVERED_CUSTOMER_DATE - O.ORDER_PURCHASE_TIMESTAMP) AS AVG_DELIVERY_TIME,
	COUNT(O.ORDER_ID) AS ORDER_COUNT,
	ROUND(AVG(R.REVIEW_SCORE),
		2) AS AVG_REVIEW_SCORE,
	COUNT(R.REVIEW_COMMENT_MESSAGE) AS COMMENT_COUNT
FROM SELLERS S
JOIN ORDER_ITEMS OI ON S.SELLER_ID = OI.SELLER_ID
JOIN ORDERS O ON O.ORDER_ID = OI.ORDER_ID
LEFT JOIN REVIEWS R ON O.ORDER_ID = R.ORDER_ID
WHERE O.ORDER_DELIVERED_CUSTOMER_DATE IS NOT NULL
GROUP BY S.SELLER_ID
HAVING COUNT(O.ORDER_ID) >
	(SELECT COUNT(DISTINCT O.ORDER_ID) / COUNT(DISTINCT S.SELLER_ID)
		FROM ORDERS O
		JOIN ORDER_ITEMS OI ON O.ORDER_ID = OI.ORDER_ID
		JOIN SELLERS S ON S.SELLER_ID = OI.SELLER_ID)
ORDER BY AVG_DELIVERY_TIME ASC,ORDER_COUNT DESC
LIMIT 5 






/*
Soru 2 : 
-Hangi satıcılar daha fazla kategoriye ait ürün satışı yapmaktadır? 
 Fazla kategoriye sahip satıcıların order sayıları da fazla mı? 
*/

SELECT S.SELLER_ID,
	COUNT(DISTINCT P.PRODUCT_CATEGORY_NAME) AS CATEGORY_COUNT,
	COUNT(O.ORDER_ID) AS ORDER_COUNT
FROM SELLERS S
JOIN ORDER_ITEMS OI ON S.SELLER_ID = OI.SELLER_ID
JOIN ORDERS O ON O.ORDER_ID = OI.ORDER_ID
JOIN PRODUCTS P ON P.PRODUCT_ID = OI.PRODUCT_ID
WHERE P.PRODUCT_CATEGORY_NAME IS NOT NULL
GROUP BY S.SELLER_ID
ORDER BY 2 DESC, 3 DESC

/*
Case 4 : Payment Analizi
Soru 1 : 
-Ödeme yaparken taksit sayısı fazla olan kullanıcılar en çok hangi bölgede yaşamaktadır? Bu çıktıyı yorumlayınız.
*/

SELECT DISTINCT C.CUSTOMER_STATE,
	ROUND(AVG(P.PAYMENT_INSTALLMENTS),2) AS AVG_INSTALLMENT_COUNT
FROM PAYMENTS AS P
JOIN ORDERS O ON O.ORDER_ID = P.ORDER_ID
JOIN CUSTOMERS C ON C.CUSTOMER_ID = O.CUSTOMER_ID
WHERE P.PAYMENT_INSTALLMENTS > 1
GROUP BY 1
ORDER BY AVG_INSTALLMENT_COUNT DESC;

/*
Soru 2 : 
-Ödeme tipine göre başarılı order sayısı ve toplam başarılı ödeme tutarını hesaplayınız. 
En çok kullanılan ödeme tipinden en az olana göre sıralayınız. */

select distinct order_status from orders

SELECT P.PAYMENT_TYPE,
	   COUNT(DISTINCT O.ORDER_ID) AS SUCCESFUL_ORDER_COUNT,
	   SUM(P.PAYMENT_VALUE)::integer AS TOTAL_PAYMENT
FROM PAYMENTS P
LEFT JOIN ORDERS O ON P.ORDER_ID = O.ORDER_ID
AND O.ORDER_STATUS = 'delivered'
GROUP BY 1
ORDER BY SUCCESFUL_ORDER_COUNT DESC


/*
Soru 3 : 
-Tek çekimde ve taksitle ödenen siparişlerin kategori bazlı analizini yapınız.
En çok hangi kategorilerde taksitle ödeme kullanılmaktadır?
*/


-- tek çekim
SELECT PR.PRODUCT_CATEGORY_NAME,
	T.CATEGORY_NAME_ENGLISH,
	COUNT(DISTINCT O.ORDER_ID) AS ORDER_COUNT
FROM PRODUCTS PR
LEFT JOIN ORDER_ITEMS OI ON PR.PRODUCT_ID = OI.PRODUCT_ID
JOIN ORDERS O ON O.ORDER_ID = OI.ORDER_ID
JOIN PAYMENTS P ON P.ORDER_ID = O.ORDER_ID
AND P.PAYMENT_INSTALLMENTS = 1
JOIN TRANSLATION T ON T.CATEGORY_NAME = PR.PRODUCT_CATEGORY_NAME
GROUP BY 1,2
ORDER BY 3 DESC


-- taksit
SELECT PR.PRODUCT_CATEGORY_NAME,
	T.CATEGORY_NAME_ENGLISH,
	COUNT(DISTINCT O.ORDER_ID) AS ORDER_COUNT
FROM PRODUCTS PR
LEFT JOIN ORDER_ITEMS OI ON PR.PRODUCT_ID = OI.PRODUCT_ID
JOIN ORDERS O ON O.ORDER_ID = OI.ORDER_ID
JOIN PAYMENTS P ON P.ORDER_ID = O.ORDER_ID
AND P.PAYMENT_INSTALLMENTS > 1
JOIN TRANSLATION T ON T.CATEGORY_NAME = PR.PRODUCT_CATEGORY_NAME
GROUP BY 1,2
ORDER BY 3 DESC

/*
Case 5 : RFM Analizi
Aşağıdaki e_commerce_data_.csv doyasındaki veri setini kullanarak RFM analizi yapınız. 
Recency hesaplarken bugünün tarihi değil en son sipariş tarihini baz alınız. 
*/




-- recency analysis
SELECT DISTINCT CUSTOMERID,
	MAX(INVOICEDATE::date) AS LAST_INVOICE_DATE,
	(SELECT MAX(INVOICEDATE::date) FROM ECOMMERCE_DATA) - INVOICEDATE::date AS RECENCY
FROM ECOMMERCE_DATA
WHERE CUSTOMERID IS NOT NULL
GROUP BY 1,
	INVOICEDATE,
	INVOICENO
ORDER BY 3 DESC

-- frequency analysis
-- cancel olan siparişler CUSTOMERID'si olmayan siparişler mi??
SELECT DISTINCT CUSTOMERID,
	COUNT(DISTINCT INVOICENO) AS FREQ
FROM ECOMMERCE_DATA
WHERE CUSTOMERID IS NOT NULL
GROUP BY 1
ORDER BY 2 DESC



-- recency + frequency analysis
SELECT DISTINCT CUSTOMERID,
	MAX(INVOICEDATE::date) AS LAST_INVOICE_DATE,
	(SELECT MAX(INVOICEDATE::date) FROM ECOMMERCE_DATA) - INVOICEDATE::date AS RECENCY,
	COUNT(INVOICENO) AS FREQ
FROM ECOMMERCE_DATA
WHERE CUSTOMERID IS NOT NULL
GROUP BY 1,
	INVOICEDATE
ORDER BY 3 ASC,4 DESC


-- monetary analysis


SELECT DISTINCT CUSTOMERID,
	SUM(QUANTITY * UNITPRICE) AS MONETARY
FROM ECOMMERCE_DATA
WHERE CUSTOMERID IS NOT NULL
GROUP BY 1
ORDER BY 2 DESC


/*
----------------------------------------------------
BURASI ÖNEMLİİİ!!!!!!!
----------------------------------------------------
*/
-- her müşterinin son rezervasyon tarihini bulalım.

SELECT DISTINCT CUSTOMERID,
	MAX(INVOICEDATE::date) AS LAST_INVOICE_DATE
FROM ECOMMERCE_DATA
WHERE CUSTOMERID IS NOT NULL
GROUP BY 1

-- her müşterinin son fatura tarihi ile bugünün tarihi arasında kaç gün var hesaplayın.
--Burada bugün son fatura tarihi gibi hesap yapılmalı, çünkü içerideki max(bookingdate) = '2011-12-09'

WITH MAX_INVOICE_DATE AS (
SELECT 
	CUSTOMERID,
	MAX(INVOICEDATE::date) AS LAST_INVOICE_DATE
FROM ECOMMERCE_DATA AS ECD
WHERE CUSTOMERID IS NOT NULL -- cancel olan siparişleri dikkate almadık.

GROUP BY 1
)
SELECT 
	customerid,
	((SELECT MAX(INVOICEDATE::date) FROM ECOMMERCE_DATA) - LAST_INVOICE_DATE::date) AS RECENCY
FROM MAX_INVOICE_DATE
	
	
-- her müşterinin bugüne kadar ki sipariş sayısını getirin.
SELECT 
	CUSTOMERID,
	COUNT(DISTINCT INVOICENO) AS FREQUENCY
FROM ECOMMERCE_DATA
WHERE CUSTOMERID IS NOT NULL -- cancel olan siparişleri dikkate almadık
GROUP BY 1
--order by 2 desc


-- her müşterinin bugüne kadarki toplam ödemi tutarını getirin.

SELECT 
	CUSTOMERID,
	SUM(QUANTITY * UNITPRICE) AS MONETARY
FROM ECOMMERCE_DATA
--WHERE CUSTOMERID IS NOT NULL -- cancel olan siparişleri dikkate almadık
WHERE INVOICENO NOT LIKE 'C%'
GROUP BY 1
------------------------------------------------------
-- şimdi herşeyi birleştirelim

WITH RFM AS 
(
WITH MAX_INVOICE_DATE AS (
SELECT 
	CUSTOMERID,
	MAX(INVOICEDATE::date) AS LAST_INVOICE_DATE
FROM ECOMMERCE_DATA AS ECD
WHERE INVOICENO NOT LIKE 'C%'
GROUP BY 1
)
SELECT CUSTOMERID,
	((SELECT MAX(INVOICEDATE::date) FROM ECOMMERCE_DATA) - LAST_INVOICE_DATE::date) AS RECENCY
FROM MAX_INVOICE_DATE ), FREQUENCY AS
(
SELECT CUSTOMERID,
	COUNT(DISTINCT INVOICENO) AS FREQUENCY
FROM ECOMMERCE_DATA
WHERE INVOICENO NOT LIKE 'C%'
GROUP BY 1
),MONETARY AS (
SELECT CUSTOMERID,
	SUM(QUANTITY * UNITPRICE) AS MONETARY
FROM ECOMMERCE_DATA
WHERE INVOICENO NOT LIKE 'C%'
GROUP BY 1
)
SELECT 
	 R.CUSTOMERID,
	 R.RECENCY,
	 F.FREQUENCY,
	 M.MONETARY,
	 NTILE(5) OVER (ORDER BY RECENCY DESC) AS RECENCY_SCORE, 
	 NTILE(5) OVER (ORDER BY FREQUENCY) AS FREQUENCY_SCORE,
	 NTILE(5) OVER (ORDER BY MONETARY) AS MONETARY_SCORE,
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) AS RFM_SCORE,
	 CASE
	 WHEN
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '11' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '12' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '21' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '22' 
	 THEN 'HIBERNATING'
	 WHEN
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '13' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '14' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '23' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '24' 
	 THEN 'AT RISK'
	  WHEN
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '15' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '25'
	 THEN 'CANT LOOSE'
	 WHEN
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '31' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '32' 
	 THEN 'ABOUT TO SLEEP'
	 WHEN CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '33'
	 THEN 'NEED ATTENTION'
	 WHEN
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '34' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '35' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '44' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '45' 
	 THEN 'LOYAL CUSTOMERS'
	 WHEN
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '41'
	 THEN 'PROMISING'
	 WHEN
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '42' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '43' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '52' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '53' 
	 THEN 'POTENTIAL LOYALISTS'
	 WHEN
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '51'
	 THEN 'NEW CUSTOMERS'
	  WHEN
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '54' OR
	 CONCAT((NTILE(5) OVER (ORDER BY RECENCY DESC)),(NTILE(5) OVER (ORDER BY FREQUENCY))) = '55' 
	 THEN 'CHAMPIONS'
	 END AS RFM_CATEGORY

FROM RFM AS R
INNER JOIN FREQUENCY F ON R.CUSTOMERID = F.CUSTOMERID
INNER JOIN MONETARY M ON R.CUSTOMERID = M.CUSTOMERID
ORDER BY F.FREQUENCY DESC




